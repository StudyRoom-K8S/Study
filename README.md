## 기간

2021.05.22 ~ 2021.07.10 (8주)

##
진행계획

- ch1 - 1주차
  - 오리엔테이션
    - 도커(필요하면)
    - 쿠버네티스(vmware)
    - 차주계획세우기, 스터디규칙만들기
- ch2 - 2주차
  - 쿠버네티스 아키텍처(각각 어떤 역활을 하는지?)
    - kubelet
    - kubeapi
    - 등등
- ch3 - 3주차
  - [06장:쿠버네티스 시작하기](#06장:쿠버네티스시작하기)
- ch4 - 4주차
  - [07장:_쿠버네티스_리소스의_관리와_설정](#07장:_쿠버네티스_리소스의_관리와_설정)
  - [08장:_인그레스(Ingress)](#8장:_인그레스(Ingress))
- ch5 - 5주차
  - [09장:_퍼시스턴트_볼륨(PV)과_퍼시스턴트_볼륨_클레임(PVC)](#09장:_퍼시스턴트_볼륨(PV)과_퍼시스턴트_볼륨_클레임(PVC))
- ch6 - 6주차
  - 10장
- ch7 - 7주차
  - 11장
- ch8 - 8주차
  - 12장 13장


## 

- 시작하세요 도커/쿠버네티스
- http://www.yes24.com/Product/Goods/84927385

### 06장:쿠버네티스시작하기

6.1 쿠버네티스를 시작하기 전에

6.2 포드(Pod) : 컨테이너를 다루는 기본 단위

- 6.2.1 포드 사용하기
- 6.2.2 포드 vs. 도커 컨테이너
- 6.2.3 완전한 애플리케이션으로서의 포드

6.3 레플리카셋(Replica Set) : 일정 개수의 포드를 유지하는 컨트롤러

- 6.3.1 레플리카셋을 사용하는 이유
- 6.3.2 레플리카셋 사용하기
- 6.3.3 레플리카셋의 동작 원리
- 6.3.4 레플리케이션 컨트롤러 vs. 레플리카셋

6.4 디플로이먼트(Deployment) : 레플리카셋, 포드의 배포를 관리

- 6.4.1 디플로이먼트 사용하기
- 6.4.2 디플로이먼트를 사용하는 이유

6.5 서비스(Service) : 포드를 연결하고 외부에 노출

- 6.5.1 서비스(Service)의 종류
- 6.5.2 ClusterIP 타입의 서비스 - 쿠버네티스 내부에서만 포드에 접근하기
- 6.5.3 NodePort 타입의 서비스 - 서비스를 이용해 포드를 외부에 노출하기
- 6.5.4 클라우드 플랫폼의 로드 밸런서와 연동하기 - LoadBalancer 타입의 서비스
- 6.5.5 트래픽의 분배를 결정하는 서비스 속성 - externalTrafficPolicy
- 6.5.6 요청을 외부로 리다이렉트하는 서비스 - ExternalName

### 07장:_쿠버네티스_리소스의_관리와_설정

7.1 네임스페이스(Namespace) : 리소스를 논리적으로 구분하는 장벽

7.2 컨피그맵(Configmap), 시크릿(Secret) : 설정값을 포드에 전달

- 7.2.1 컨피그맵(Configmap)
- 7.2.2 시크릿(Secret)

### 08장:_인그레스(Ingress)

8.1 인그레스를 사용하는 이유

8.2 인그레스의 구조

8.3 인그레스의 세부 기능 : annotation을 이용한 설정

8.4 Nginx 인그레스 컨트롤러에 SSL/TLS 보안 연결 적용

8.5 여러 개의 인그레스 컨트롤러 사용하기

### 09장:_퍼시스턴트_볼륨(PV)과_퍼시스턴트_볼륨_클레임(PVC)

9.1 로컬 볼륨 : hostPath, emptyDir

- 9.1.1 워커 노드의 로컬 디렉터리를 볼륨으로 사용 : hostPath
- 9.1.2 포드 내의 컨테이너 간 임시 데이터 공유 : emptyDir

9.2 네트워크 볼륨

9.3 PV, PVC를 이용한 볼륨 관리

- 9.3.1 퍼시스턴트 볼륨과 퍼시스턴트 볼륨 클레임을 사용하는 이유
- 9.3.2 퍼시스턴트 볼륨과 퍼시스턴트 볼륨 클레임 사용하기
- 9.3.3 퍼시스턴트 볼륨을 선택하기 위한 조건 명시
- 9.3.4 퍼시스턴트 볼륨의 라이프사이클과 Reclaim Policy
- 9.3.5 StorageClass와 Dynamic Provisioning

### 10장: 보안을 위한 인증과 인가 - ServiceAccount와 RBAC

10.1 쿠버네티스의 권한 인증 과정

10.2 서비스 어카운트와 롤(Role), 클러스터 롤(Cluster Role)

10.3 쿠버네티스 API 서버에 접근

- 10.3.1 서비스 어카운트의 시크릿을 이용해 쿠버네티스 API 서버에 접근
- 10.3.2 클러스터 내부에서 kubernetes 서비스를 통해 API 서버에 접근
- 10.3.3 쿠버네티스 SDK를 이용해 포드 내부에서 API 서버에 접근

10.4 서비스 어카운트에 이미지 레지스트리 접근을 위한 시크릿 설정

10.5 kubeconfig 파일에 서비스 어카운트 인증 정보 설정

10.6 유저(User)와 그룹(Group)의 개념

10.7 x509 인증서를 이용한 사용자 인증

### 11장: 애플리케이션 배포를 위한 고급 설정

11.1 포드의 자원 사용량 제한

- 11.1.1 컨테이너와 포드의 자원 사용량 제한 : Limit
- 11.1.2 컨테이너와 포드의 자원 사용량 제한하기 : Request
- 11.1.3 CPU 자원 사용량의 제한 원리
- 11.1.4 QoS 클래스와 메모리 자원 사용량 제한 원리
- 11.1.5 ResourceQuota와 LimitRanger
- 11.1.6 ResourceQuota, LimitRanger의 원리 : Admission Controller

11.2 쿠버네티스 스케줄링

- 11.2.1 포드가 실제로 노드에 생성되기까지의 과정
- 11.2.2 포드가 생성될 노드를 선택하는 스케줄링 과정
- 11.2.3 NodeSelector와 Node Affinity, Pod Affinity
- 11.2.4 Taints와 Tolerations 사용하기
- 11.2.5 Cordon, Drain 및 PodDistributionBudget
- 11.2.6 커스텀 스케줄러 및 스케줄러 확장

11.3 쿠버네티스 애플리케이션 상태와 배포

- 11.3.1 디플로이먼트를 통해 롤링 업데이트
- 11.3.2 포드의 생애 주기(Lifecycle)
- 11.3.3 HPA를 활용한 오토스케일링

### 12장: 커스텀 리소스와 컨트롤러

12.1 쿠버네티스 컨트롤러의 개념과 동작 방식

12.2 커스텀 리소스에 대한 개념

12.3 커스텀 리소스를 정의하기 위한 CRD(Custom Resource Definition)

12.4 커스텀 리소스와 컨트롤러

### 13장: 포드를 사용하는 다른 오브젝트들

13.1 잡(Jobs)

13.2 데몬셋(DaemonSets)

13.3 스테이트풀셋(StatefulSets)

### 14장: 쿠버네티스 모니터링

14.1 모니터링 기본 구조

14.2 모니터링 메트릭의 분류

14.3 쿠버네티스 모니터링 기초

- 14.3.1 metrics-server
- 14.3.2 metrics-server 동작 원리: APIService 리소스
- 14.3.3 kube-state-metrics
- 14.3.4 node-exporter

14.4 프로메테우스를 활용한 메트릭 수집

- 14.4.1 프로메테우스 설치
- 14.4.2 프로메테우스로 메트릭 수집하기
- 14.4.3 그라파나로 프로메테우스 메트릭 시각화하기